<!DOCTYPE HTML>
<html>

<head>
  <title>MLgym Dashboard</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/3.0.4/socket.io.js" integrity="sha512-aMGMvNYu8Ue4G+fHa359jcPb1u+ytAF+P2SCb+PxrjCdO3n3ZTxJ30zuH39rimUggmTwmh2u7wvQsDTHESnmfQ==" crossorigin="anonymous"></script>
  <link href="https://unpkg.com/tabulator-tables@5.2.3/dist/css/tabulator.min.css" rel="stylesheet">
  <script type="text/javascript" src="https://unpkg.com/tabulator-tables@5.2.3/dist/js/tabulator.min.js"></script>

  <style media="screen">
    table {
      margin: 25px 0;
    }

    table th,
    table td {
      padding: 10px;
      text-align: center;
    }

    table,
    th,
    td {
      border-bottom: : 1px solid;
    }
  </style>
  <script type="text/javascript" charset="utf-8">


    $(document).ready(function() {
      // Connect to the Socket.IO server.
      // The connection URL has the following format, relative to the current page:
      //     http[s]://<domain>:<port>[/<namespace>]
      var socket = io("http://localhost:11127");

      // Event handler for new connections.
      // The callback function is invoked when a connection with the
      // server is established.
      socket.on('connect', function() {
        socket.emit('join', {
          rooms: ['mlgym_event_subscribers']
        });

      });



      //const experiments = new Map();
      const table = new Tabulator("#experiments", {
        height :"500px",
        layout:"fitDataTable",
        layout:"fitDataStretch",
        pagination: "local", //paginate the data
        paginationSize: 12, //allow 12 rows per page of data
        paginationCounter: "rows", //display count of paginated rows in footer
        columns: [ //define the table columns
          {
            title: "ID",
            field: "id"
          },
          {
            title: "Status",
            field: "status",
          },
          {
            title: "Current Epoch",
            field: "currentEpoch"
          },
          {
            title: "Epoch Progress",
            field: "epochProgress"
          },
          {
            title: "Current Split",
            field: "currentSplit",
          },
          {
            title: "Current Batch",
            field: "currentBatch",
          },
        ],
      });

      function updateExperiment(expId) {
        experiments.set(expId, {
          status: msg_json.data.payload.status,
          total_epochs: msg_json.data.payload.num_epochs,
          current_epoch: msg_json.data.payload.current_epoch,
          split: msg_json.data.payload.current_split,
          total_batches: msg_json.data.payload.num_batches,
          current_batch: msg_json.data.payload.current_batch
        });
      };

      // Event handler for server sent data.
      // The callback function is invoked whenever the server emits data
      // to the client. The data is then displayed in the "Received"
      // section of the page.
      socket.on('mlgym_event', function(msg, cb) {
        msg_json = JSON.parse(msg);
        msg_string = JSON.stringify(msg_json);


        //$('#log').append('<br>' + $('<div/>').text('<mlgym_event>: ' + msg_string).html());
        // if (msg_json.data.event_type === "job_status") {
        //   $("#jobs_table").append("<tr><td>" + msg_json.event_id + "<td>" + msg_json.data.event_type + "</td></tr>");
        //
        // }
        //    $('#log').append('<br>' + $('<div/>').text('<id>: ' + msg_json.event_id).html());
        //    $('#log').append('<br>' + $('<div/>').text('<type of event>: ' + msg_json.data.event_type).html());


        if (msg_json.data.event_type === "experiment_status") {

          const data = [{
            id: msg_json.data.payload.experiment_id,
            status: msg_json.data.payload.status,
            currentEpoch: msg_json.data.payload.current_epoch,
            epochProgress: 0,
            currentSplit: msg_json.data.payload.current_split,
            currentBatch: msg_json.data.payload.current_batch
          }]

          table.updateOrAddData(data);
        };

        //   if (table.getData(msg_json.data.payload.experiment_id) === msg_json.data.payload.experiment_id) {
        //     updateExperiment(msg_json.data.payload.experiment_id);
        //     const data = [{
        //       id: msg_json.data.payload.experiment_id,
        //       status: msg_json.data.payload.status,
        //       currentEpoch: msg_json.data.payload.current_epoch,
        //       epochProgress: 0,
        //       currentSplit: msg_json.data.payload.current_split,
        //       currentBatch: msg_json.data.payload.current_batch
        //     }]
        //
        //     table.updateOrAddData(data);
        //
        //   } else {
        //     updateExperiment(msg_json.data.payload.experiment_id);
        //     const data = [{
        //       id: msg_json.data.payload.experiment_id,
        //       status: msg_json.data.payload.status,
        //       currentEpoch: msg_json.data.payload.current_epoch,
        //       epochProgress: 0,
        //       currentSplit: msg_json.data.payload.current_split,
        //       currentBatch: msg_json.data.payload.current_batch
        //     }]
        //     table.addData(data);
        //
        //   }
        // }

        if (cb)
          cb();
      });

      socket.on('server_log_message', function(msg, cb) {
        $('#log').append('<br>' + $('<div/>').text('<server_log_message>: ' + msg).html());
        if (cb)
          cb();
      });


      // Interval function that tests message latency by sending a "ping"
      // message. The server then responds with a "pong" message and the
      // round trip time is measured.
      var ping_pong_times = [];
      var start_time;
      window.setInterval(function() {
        start_time = (new Date).getTime();
        $('#transport').text(socket.io.engine.transport.name);
        socket.emit('ping');
      }, 1000);

      // Handler for the "pong" message. When the pong is received, the
      // time from the ping is stored, and the average of the last 30
      // samples is average and displayed.
      socket.on('pong', function() {
        var latency = (new Date).getTime() - start_time;
        ping_pong_times.push(latency);
        ping_pong_times = ping_pong_times.slice(-30); // keep last 30 samples
        var sum = 0;
        for (var i = 0; i < ping_pong_times.length; i++)
          sum += ping_pong_times[i];
        $('#ping-pong').text(Math.round(10 * sum / ping_pong_times.length) / 10);
      });
    });
  </script>
</head>

<body>
  <h1>MLgym Dashboard</h1>
  <p>
    Async mode is: <b>{{ async_mode }}</b><br>
    Current transport is: <b><span id="transport"></span></b><br>
    Average ping/pong latency: <b><span id="ping-pong"></span>ms</b>
  </p>
  <h2>Log messages</h2>

  <div id="experiments"></div>

</body>

</html>
